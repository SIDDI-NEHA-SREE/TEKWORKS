# -*- coding: utf-8 -*-
"""D8(02).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lNwI-YIWBVAnXEf9IUOBXyH0bC5uMzX4
"""

import numpy as np

arr=np.array([1,2,3])
print(arr)

arr2=np.array([[1,2,3],[4,5,6]])
print(arr2)

arr3=np.array([[[1,2,3],[4,5,6],[7,8,9]]])
print(arr3)

#to know the dimensions of the arrays
print(arr.ndim)
print(arr2.ndim)
print(arr3.ndim)

# zreo array-creates an array of zeros with given(rows,columns)
z=np.zeros((2,3))
print(z)
# one array-creates an array of ones with given(rows,columns)
o=np.ones((2,3))
print(o)

#randow array-creates an array of random values with given(rows,columns)
print(np.random.random((2,2)))
#identity matrix
print(np.eye(3))

#array with a range of values
print(np.arange(0,10,2))#start stop,step

#array attributes
ar=np.array([[1,2,3],[4,5,6]])
print("Shape: ",ar.shape)
print("Size: ",ar.size)
print("Data type:",ar.dtype)
print("Number od dimensions: ",ar.ndim)

"""TASK-1
You are working as a Data Engineer for a smart agriculture startup that collects sensor data from multiple greenhouses.
 Each greenhouse has sensors that record temperature (°C) readings at different times of the day.
You received the following data:

Your tasks are:
Create NumPy arrays
Create a 2D NumPy array named temp_data to represent the temperature readings from both greenhouses.
Print the array.
Check array properties
Print the shape, size, data type, and number of dimensions of temp_data.
Add a third greenhouse
The third greenhouse (GH3) records [21, 23, 22].
Create a new array updated_temp_data that includes all three greenhouses.
Generate supporting data
Create a zeros array (2×3) called sensor_error_flags to represent whether there were any sensor errors (0 means no error).
Create an identity matrix of size 3×3 named greenhouse_identity to uniquely identify each greenhouse.
Display all arrays
Print updated_temp_data, sensor_error_flags, and greenhouse_identity.

"""

# data engineer-task1
import numpy as np
temp_data=np.array([[22,25,20],[24,26,23]])
print(temp_data)
print("Shape: ",temp_data.shape)
print("Size: ",temp_data.size)
print("Data type:",temp_data.dtype)
print("Number of dimensions: ",temp_data.ndim)

GH3=np.array([21, 23, 22])
updated_temp_data = np.vstack([temp_data, GH3])
print("Updated data:\n",updated_temp_data)
sensor_error_flags=np.zeros((2,3))
print("Sensor flag:\n",sensor_error_flags)
greenhouse_identity=np.eye(3)
print("Green House:\n",greenhouse_identity)

"""TASK-2
Indexing and Slicing:
You are working as a Data Analyst at a fruit distribution company.

The company stores the number of fruit boxes shipped per day (for 1 week) in a 2D NumPy array where:
Each row represents a type of fruit.
Each column represents a day of the week (Mon–Sun).


Your Tasks
Create the 2D NumPy array

Create an array named shipments using the above data.
Access single elements (Indexing):
Get the number of Apples shipped on Wednesday.
Get the number of Oranges shipped on Sunday.
Access multiple elements (Slicing):
Extract all the weekday shipments (Mon–Fri) for all fruits.
Extract only the weekend shipments (Sat & Sun).
Extract the shipments of Apples from Wednesday to Saturday.
Bonus (Practice thinking):
Replace the Saturday shipment of Apples (currently 80) with 100 using indexing.

"""

# indexing and slicing task2
import numpy as np
Apples=np.array([50,60,55,70,65,80,90])
Oranges=np.array([40,45,50,60,55,70,75])
shipments=np.array([Apples,Oranges])
print(shipments)
print("Number of apples shipped on Wednesday: ",shipments[0,2])
print("Number of oranges shipped on Sunday: ",shipments[1,6])
print("On weekdays-all fruits: \n",shipments[:,0:5])
print("On weekends-all fruits: \n",shipments[:,5:7])
print("Apples from Wednesday to Saturday: \n",shipments[0,2:6])
shipments[0,5]=100
print("Updated shipments: \n",shipments)

#martix operations
a=np.array([1,2,3])
b=np.array([4,5,6])
print(a+b)
print(a-b)
print(a*b)
print(a*2)

# operations
Arr=np.array([40,90,20])
x=np.array([1,2,3])
y=np.array([4,5,6])
print(np.add(Arr,2))
print(np.subtract(Arr,2))
print(np.multiply(Arr,2))
print(np.divide(Arr,2))
print(np.power(Arr,2))
print(np.mod(Arr,2))
#exponential
print(np.exp(Arr))
print(np.log(Arr))
print(np.log2(Arr))
print(np.log10(Arr))
print(np.expm1(Arr))
#trigonometric fnctions
print(np.sin(Arr))
print(np.cos(Arr))
print(np.tan(Arr))
print(np.arcsin(Arr))
print(np.arccos(Arr))
print(np.arctan(Arr))
print(np.degrees(Arr))
print(np.radians(Arr))
#Rounding ufuncs
print(np.round(Arr))
print(np.floor(x))
print(np.ceil(x))
print(np.trunc(x))
#Statistical ufuncs
#(Operate along an axis or entire array)
print(np.min(x))
print(np.max(x))
print(np.mean(x))
print(np.std(x))
print(np.var(x))
print(np.sum(x))
print(np.prod(x))
# Logical ufuncs
print(np.logical_and(x, y))
print(np.logical_or(x, y))
print(np.logical_not(x))
print(np.logical_xor(x, y))
# Comparison ufuncs
#(Return Boolean arrays)
print(np.greater(x, y))
print(np.less(x, y))
print(np.equal(x, y))
print(np.not_equal(x, y))
print(np.greater_equal(x, y))
print(np.less_equal(x, y))
#Bitwise ufuncs
#(Operate on integers)
print(np.bitwise_and(x, y))
print(np.bitwise_or(x, y))
print(np.bitwise_xor(x, y))
print(np.invert(x))

"""TASK
You are a data engineer at a renewable-energy company that runs 3 solar farms.
 Each farm has 4 solar panels, and each panel reports hourly energy production (kWh) for 3 hours during a test window.

Given data (raw)
Create arrays from these values:
production — shape (3 farms × 4 panels × 3 hours) represented as a 2D array per farm (you can stack/create as shown in tasks).
Farm A panels (rows = panels, cols = hours):


Tasks
Create arrays
Create three 2D NumPy arrays farmA, farmB, farmC (each shape (4,3)).
Stack them into a single 3D array production_all of shape (3, 4, 3).
Array attributes
Print the .shape, .size, .dtype, and .ndim of production_all.
Per-farm totals (arithmetic & aggregation)
Use aggregation ufuncs to compute the total energy per farm (sum across panels & hours) → total_per_farm (shape (3,)).
Compute mean, std, and var per farm.
Per-hour matrix multiplication idea (matrix op)
For a quick weighted estimate, create a hour_weights row vector of shape (3,) = [0.5, 1.0, 0.75] (weights for hour1, hour2, hour3).
Compute weighted_per_panel by performing a dot product between each farm's panel-row and hour_weights to get per-panel weighted energy. (Use np.dot / matrix multiplication appropriately.)
Broadcasting adjustments
The operator notices a fixed calibration offset of +0.5 kWh for all panels in Farm B. Use broadcasting to add this offset to Farm B data inside production_all (without recreating whole array manually).
Element-wise arithmetic (ufuncs: add/sub/mul/div/power/mod)
Compute a normalized version where you:
subtract the per-farm mean (use broadcasting),
divide by the per-farm std (broadcasting) — i.e., z-score normalize each farm's panel-hour readings.
Apply many ufuncs (use the ufuncs listed previously)
 Apply the following element-wise operations (create variables for each) on the normalized data (or a copy) and show the resulting arrays (or summaries — shape/dtype/first row) where appropriate:
Exponential family: np.exp, np.expm1, np.log (note: handle non-positive inputs if needed), np.log10, np.log2.
Trigonometric: np.sin, np.cos, np.tan, np.arcsin, np.arccos, np.arctan, plus np.degrees, np.radians applied appropriately.
Rounding: np.round, np.floor, np.ceil, np.trunc.
Comparison & logical ufuncs: create a boolean mask high_output = production_all > 20 and apply np.logical_and, np.logical_or, np.logical_not, np.logical_xor combining masks (e.g., high_output and even_hours_mask). Also use comparison ufuncs like np.greater_equal, np.less.
Bitwise ufuncs (on integer arrays): create an integer array alerts = np.array([[1,0,1],[0,0,1],[1,1,0],[0,1,0]]) for each farm (shape match required) — then apply np.bitwise_and, np.bitwise_or, np.invert where sensible.
Arithmetic ufuncs again: np.add, np.subtract, np.multiply, np.divide, np.power, np.mod.
Aggregations over ufunc outputs: e.g., np.sum(np.exp(...)), np.mean(np.sin(...)).
Broadcast-based summary table
Use broadcasting to compute a (3,4) array panel_totals_per_farm = total per panel (sum across hours for each panel), and then compute a (3,) boolean needs_maintenance saying True if any panel in that farm has total < 40. Use np.min, np.max, np.any, np.all.
Final KPIs (aggregation)
Compute:
overall_total (sum of all farms),
peak_hour value (max across hours) and which farm & panel produced it (use np.argmax with careful unraveling),
average_per_panel across all farms.

"""

import numpy as np

# 1
farmA = np.array([
    [12.5, 15.2, 14.8],
    [10.1, 11.3, 13.7],
    [9.8,  10.6, 11.2],
    [14.2, 13.9, 15.0]
])

farmB = np.array([
    [14.0, 14.7, 15.3],
    [13.2, 12.9, 13.8],
    [15.6, 16.1, 16.5],
    [12.4, 13.0, 13.5]
])

farmC = np.array([
    [11.5, 12.1, 12.9],
    [10.8, 11.2, 11.6],
    [13.4, 13.8, 14.1],
    [12.0, 12.5, 12.9]
])
production_all = np.array([farmA, farmB, farmC])
print(production_all)

# 2
print("Shape:", production_all.shape)
print("Size:", production_all.size)
print("Dtype:", production_all.dtype)
print("Dimensions:", production_all.ndim)
print()

#3

print("Total per farm:",np.sum(production_all, axis=(1,2)))
print("Mean per farm:", np.mean(production_all, axis=(1,2)))
print("Std per farm:", np.std(production_all, axis=(1,2)))
print("Var per farm:", np.var(production_all, axis=(1,2)))
print()

#4
hour_weights = np.array([0.5, 1.0, 0.75])
weighted_per_panel = np.tensordot(production_all, hour_weights, axes=(2,0))
print("Weighted per-panel output:\n", weighted_per_panel)
print()

# 5
production_all[1] += 0.5
print("add/sub/mul/div/power/mod")
print("add",np.add(production_all, 2))
print(np.subtract(production_all, 2))
print(np.multiply(production_all, 2))
print(np.divide(production_all, 2))
print()
# 6
means = production_all.mean(axis=(1,2), keepdims=True)
stds  = production_all.std(axis=(1,2), keepdims=True)
normalized = (production_all - means) / stds

# 7
exp_vals    = np.exp(normalized)
log_vals    = np.log(normalized - normalized.min() + 1e-3)   # shift positive
sin_vals    = np.sin(normalized)
cos_vals    = np.cos(normalized)
rounded_vals = np.round(normalized, 2)

print("Example exp mean:", exp_vals.mean())
print("Example sin mean:", sin_vals.mean())
print()

#8
high_output = production_all > 20
even_hours_mask = (np.arange(3) % 2 == 0)
even_hours_mask = np.broadcast_to(even_hours_mask, production_all.shape)

combined_mask = np.logical_and(high_output, even_hours_mask)
print("Any high output >20 kWh:", np.any(high_output))
print()

# 9
alerts = np.array([[1,0,1,0]] * 3, dtype=int)
bit_and = np.bitwise_and(alerts, alerts)
bit_or  = np.bitwise_or(alerts, alerts)
bit_not = np.bitwise_not(alerts)
print("Bitwise NOT sample:\n", bit_not)
print()

# 10
added      = np.add(farmA, farmC)
subtracted = np.subtract(farmB, farmA)
multiplied = np.multiply(farmA, farmC)
divided    = np.divide(farmA, farmB)
powered    = np.power(farmA, 2)
modded     = np.mod(farmA, 5)

# 11
sum_exp   = np.sum(exp_vals)
mean_sin  = np.mean(sin_vals)

# 12
panel_totals = np.sum(production_all, axis=2)
needs_maintenance = panel_totals < 40

# 9
overall_total = np.sum(production_all)
peak_hr = np.max(production_all)
peak_index = np.unravel_index(np.argmax(production_all), production_all.shape)
average_per_panel = np.mean(panel_totals, axis=0)

print("Overall total production:", overall_total)
print("Peak Hour:", peak_hr, "at (farm,panel,hour):", peak_index)
print("Average per panel across farms:", average_per_panel)
print("Farms needing maintenance:\n", needs_maintenance)

arr=np.array([1,2,3,4,5,6])
print(arr.reshape(2,3))

a=np.array([1,2])
b=np.array([3,4])
print(np.vstack((a,b)))
print(np.hstack((a,b)))
arr=np.array([1,2,3,4,5,6])
print(np.array_split(arr,3))
print(arr[arr>3])
indices=[0,2]
print(arr[indices])

copy=arr.copy()
copy[0]=10
print(arr)

A=np.array([1,2,3])
np.save('array.npy',A)
loaded=np.load('array.npy')
print(loaded)

